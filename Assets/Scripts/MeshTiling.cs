using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using UnityEngine;
using SplineMesh;

#if UNITY_EDITOR
using UnityEditor.Experimental.SceneManagement;
#endif

public enum TilingMode
{
    EfficientRepeatMesh,
    SlowStretchMesh
}

/// <summary>
/// Deform a mesh and place it along a spline, given various parameters.
/// 
/// This class intend to cover the most common situations of mesh bending. It can be used as-is in your project,
/// or can serve as a source of inspiration to write your own procedural generator.
/// </summary>
[ExecuteInEditMode]
[SelectionBase]
[DisallowMultipleComponent]
public class MeshTiling : MonoBehaviour
{
    private GameObject generated;
    private Spline spline = null;
    private bool toUpdate = false;

    [SerializeField]
    [Tooltip("Mesh to bend along the spline.")]
    private Mesh mesh;
    public Mesh Mesh 
    { 
        get => mesh;
        set
        {
            mesh = value;
            toUpdate = true;
        }
    }

    [SerializeField]
    [Tooltip("Material to apply on the bent mesh.")]
    private Material material;
    public Material Material
    {
        get => material;
        set
        {
            material = value;
            toUpdate = true;
        }
    }

    [SerializeField]
    [Tooltip("Translation to apply on the mesh before bending it.")]
    private Vector3 translation;
    public Vector3 Translation
    {
        get => translation;
        set
        {
            translation = value;
            toUpdate = true;
        }
    }

    [SerializeField]
    [Tooltip("Rotation to apply on the mesh before bending it.")]
    private Vector3 rotation;
    public Vector3 Rotation
    {
        get => rotation;
        set
        {
            rotation = value;
            toUpdate = true;
        }
    }

    [SerializeField]
    [Tooltip("Scale to apply on the mesh before bending it.")]
    private Vector3 scale = Vector3.one;
    public Vector3 Scale
    {
        get => scale;
        set
        {
            scale = value;
            toUpdate = true;
        }
    }

    // [Tooltip("If true, the mesh will be bent on play mode. If false, the bent mesh will be kept from the editor mode, allowing lighting baking.")]
    private bool updateInPlayMode = true;

    [SerializeField]
    private TilingMode tilingMode;
    public TilingMode TilingMode
    {
        get => tilingMode;
        set
        {
            tilingMode = value;
            switch (tilingMode)
            {
                case TilingMode.EfficientRepeatMesh:
                    curveSpace = false;
                    mode = MeshBender.FillingMode.Repeat;
                    break;
                case TilingMode.SlowStretchMesh:
                    curveSpace = true;
                    mode = MeshBender.FillingMode.StretchToInterval;
                    break;
            }
            toUpdate = true;
        }
    }

    //[SerializeField]
    //[Tooltip("If true, a mesh will be placed on each curve of the spline. If false, a single mesh will be placed for the whole spline.")]
    private bool curveSpace = false;
    //public bool CurveSpace
    //{
    //    get => curveSpace;
    //    set
    //    {
    //        curveSpace = value;
    //        toUpdate = true;
    //    }
    //}

    //[SerializeField]
    //[Tooltip("The mode to use to fill the choosen interval with the bent mesh.")]
    private MeshBender.FillingMode mode = MeshBender.FillingMode.Repeat;
    //public MeshBender.FillingMode Mode
    //{
    //    get => mode;
    //    set
    //    {
    //        mode = value;
    //        toUpdate = true;
    //    }
    //}

    private void OnEnable()
    {
        // tip : if you name all generated content in the same way, you can easily find all of it
        // at once in the scene view, with a single search.
        string generatedName = "generated by " + GetType().Name;
        var generatedTranform = transform.Find(generatedName);
        generated = generatedTranform != null ? generatedTranform.gameObject : UOUtility.Create(generatedName, gameObject);

        spline = GetComponentInParent<Spline>();
        spline.NodeListChanged += (s, e) => toUpdate = true;

        TilingMode = TilingMode.EfficientRepeatMesh;

        toUpdate = true;
    }

    private void OnValidate()
    {
        if (spline == null) return;
        toUpdate = true;
    }

    private void Update()
    {
        // we can prevent the generated content to be updated during playmode to preserve baked data saved in the scene
        if (!updateInPlayMode && Application.isPlaying) return;

        if (toUpdate)
        {
            toUpdate = false;
            CreateMeshes();
        }
    }

    public void CreateMeshes()
    {
#if UNITY_EDITOR
        // we don't update if we are in prefab mode
        if (PrefabStageUtility.GetCurrentPrefabStage() != null) return;
#endif
        var used = new List<GameObject>();

        if (curveSpace)
        {
            int i = 0;
            foreach (var curve in spline.curves)
            {
                var go = FindOrCreate("segment " + i++ + " mesh");
                go.GetComponent<MeshBender>().SetInterval(curve);
                used.Add(go);
            }
        }
        else
        {   
            var go = FindOrCreate("segment 1 mesh");
            go.GetComponent<MeshBender>().SetInterval(spline, 0);
            used.Add(go);
        }

        // we destroy the unused objects. This is classic pooling to recycle game objects.
        foreach (var go in generated.transform
            .Cast<Transform>()
            .Select(child => child.gameObject).Except(used))
        {
            UOUtility.Destroy(go);
        }
    }

    private GameObject FindOrCreate(string name)
    {
        var childTransform = generated.transform.Find(name);
        GameObject res;
        if (childTransform == null)
        {
            res = UOUtility.Create(name,
                generated,
                typeof(MeshFilter),
                typeof(MeshRenderer),
                typeof(MeshBender));
            res.isStatic = !updateInPlayMode;
        }
        else
        {
            res = childTransform.gameObject;
        }
        res.GetComponent<MeshRenderer>().material = Material;
        MeshBender mb = res.GetComponent<MeshBender>();
        mb.Source = SourceMesh.Build(Mesh)
            .Translate(Translation)
            .Rotate(Quaternion.Euler(Rotation))
            .Scale(Scale);
        mb.Mode = mode;
        return res;
    }
}
